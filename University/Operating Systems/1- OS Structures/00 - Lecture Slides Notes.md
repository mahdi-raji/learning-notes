**قبل از خوندن اینا بهتره که هر 15 تا فایل داخل فولدر خونده بشه؛ شاید مباحثش شبیه نباشن ولی زیر ساختای اولیه رو برای فهمیدن مباحث پایین ایجاد میکنه که باعث راحت تر فهمیدن مباحث زیر میشه **

![](attachments/Pasted%20image%2020250614160516.png)
![](attachments/Pasted%20image%2020250614160527.png)![](attachments/Pasted%20image%2020250614160533.png)![](attachments/Pasted%20image%2020250614160543.png)![](attachments/Pasted%20image%2020250614160557.png)![](attachments/Pasted%20image%2020250614160604.png)![](attachments/Pasted%20image%2020250614160617.png)![](attachments/Pasted%20image%2020250614160628.png)

![](attachments/Pasted%20image%2020250614160650.png)
![](attachments/Pasted%20image%2020250614160715.png)

![](attachments/Pasted%20image%2020250614160724.png)

تفاوت میان off-line و off-line spooling  در نحوه ذخیره سازی می‌باشد که job spool در ابتدا در نوار های مغناطیسی ذخیره می‌‎شد که بعدا در دیسک ذخیره شدند.

![](attachments/Pasted%20image%2020250614160908.png)
![](attachments/Pasted%20image%2020250614160932.png)

بدون اسپولینگ، سیستم‌های چندبرنامه‌ای عملاً نمی‌تونستن خوب کار کنن، چون CPU برای بارگذاری Job بعدی منتظر دستگاه‌های کند I/O (مثل کارت‌خوان) می‌موند و کارایی پایین می‌اومد.
اسپولینگ با ذخیره Jobها روی دیسک و فراهم کردن دسترسی سریع، امکان چندبرنامه‌ای رو عملی کرد و باعث شد CPU همیشه مشغول باشه.

![](attachments/Pasted%20image%2020250614160943.png)

تو سیستم‌های اشتراک زمانی (Time-Sharing Systems)، یه کامپیوتر مرکزی (معمولاً یه ماشین بزرگ و قوی) بود، ولی چند نفر می‌تونستن همزمان ازش استفاده کنن. هر نفر از طریق یه ترمینال (مثل یه کیبورد و مانیتور ساده) به کامپیوتر وصل می‌شد و انگار سیستم فقط مال خودش بود.
مثل یه گارسون تو رستوران که بین چند میز خیلی سریع می‌چرخه و به هر مشتری یه کم رسیدگی می‌کنه. مشتریا حس می‌کنن گارسون فقط مال اونا ست، ولی در واقع داره بین همه تقسیم می‌شه.
![](attachments/Pasted%20image%2020250614161001.png)
در متقارن shared هست و همگی باهم کار می‌کنند ولی در نامتقارن، یک سیستم به عنوان master در نظر گرفته می‌شود.
![](attachments/Pasted%20image%2020250614161054.png)
سیستمیه که از چند کامپیوتر (یا گره - Node) تشکیل شده که با هم ارتباط دارن و با همکاری کار می‌کنن.
کاربر این کامپیوترها رو به‌عنوان یه سیستم واحد می‌بینه، انگار که داره با یه کامپیوتر قوی کار می‌کنه، در حالی که در واقع چند کامپیوتر دارن باهم کار می‌کنن.
به این سیستم‌ها ارتباط سست (Loosely Coupled) می‌گن، چون هر کامپیوتر حافظه و CPU خودش رو داره و از طریق شبکه (مثل اینترنت یا شبکه محلی) با بقیه ارتباط برقرار می‌کنه، برخلاف سیستم‌های چندپردازنده‌ای که حافظه مشترک دارن.


![](attachments/Pasted%20image%2020250614161059.png)
در سیستم های hard real time:
تناقض با اشتراک زمانی: این سیستم‌ها نمی‌تونن با سیستم‌های اشتراک زمانی (که چند کاربر همزمان کار می‌کنن) ترکیب بشن، چون اشتراک زمانی ممکنه باعث تأخیر بشه.
مثال: سیستم‌های کنترل موتور هواپیما، دستگاه‌های پزشکی مثل ضربان‌ساز قلب.


![](attachments/Pasted%20image%2020250614162259.png)

## Pipeline :

 پایپ لاین :CPU مراحل مختلف دستورات (واکشی، کدگشایی، اجرا) رو همزمان برای دستورات مختلف انجام می‌ده. 
    
  **سرعت بیشتر**: به‌جای اینکه CPU منتظر بمونه تا یه دستور کامل تموم بشه، همزمان روی چند دستور کار می‌کنه. این مثل یه خط تولید تو کارخانه‌ست که هر بخش کار خودشو انجام می‌ده.
  
 **کارایی بالاتر:**  CPU کمتر بیکار می‌مونه و تعداد دستوراتی که تو یه زمان انجام می‌شه (Throughput) بیشتر می‌شه.

![](attachments/Pasted%20image%2020250614162848.png)



## Super Scalar Pipe line:

- سوپر اسکالر یه نسخه **پیشرفته‌تر** از خط لوله‌ست که توش **چند واحد اجرا (Execution Units)** وجود داره. یعنی CPU می‌تونه **چند دستور** رو همزمان اجرا کنه.
- **واحدهای اجرا**:
    - یه واحد برای **محاسبات صحیح (Integer Operations)** مثل جمع و تفریق اعداد.
    - یه واحد برای **محاسبات ممیز شناور (Floating-Point Operations)** مثل عملیات ریاضی پیچیده.
    - یه واحد برای **عملیات بولی (Boolean Operations)** مثل بررسی شرط‌ها (درست/غلط).

**بافر:** دستورات اول واکشی می‌شن و تو یه بافر (حافظه موقت) ذخیره می‌شن. CPU نگاه می‌کنه که کدوم واحد اجرا آزاده، بعد دستور مناسب (مثلاً یه محاسبه صحیح یا ممیز شناور) رو از بافر برمی‌داره و اجرا می‌کنه.

**خارج از ترتیب (Out-of-Order Execution):** دستورات ممکنه به ترتیب غیر از ترتیب اصلی برنامه اجرا بشن. مثلاً اگه یه دستور منتظر داده باشه، CPU می‌تونه دستور بعدی رو که آماده‌ست اجرا کنه. 
این باعث می‌شه سرعت خیلی بیشتر بشه.

 - **مقایسه با خط لوله معمولی:**
- تو **خط لوله (Pipelining)** ساده، فقط مراحل مختلف یه دستور (واکشی، کدگشایی، اجرا) همزمان انجام می‌شن، ولی هنوز فقط یه دستور تو هر لحظه اجرا می‌شه.
- تو **سوپر اسکالر**، چند دستور می‌تونن **همزمان اجرا** بشن، چون چند واحد اجرا داریم. این باعث می‌شه سرعت خیلی بیشتر بشه.
## I / O 
توضیحات خودم تو فایل 4 ام کاملتره.
- روش های انتقال IO : 
1- **برنامه نویسی شده:**
![](attachments/Pasted%20image%2020250614164138.png)
در این روش، به دلیل کند بودن مولفه‌های I/O، CPU در حلقه‌ای مدام وضعیت را چک می‌کند (Busy Waiting) و این باعث اتلاف زمان و کاهش کارایی سیستم می‌شود. 

2- **INTERUPT**
![](attachments/Pasted%20image%2020250614164255.png)
![](attachments/Pasted%20image%2020250614164331.png)

- **گام ۱**: CPU به کنترل‌کننده I/O دستور می‌ده و رجیسترها رو تنظیم می‌کنه.
- **گام ۲**: کنترل‌کننده I/O وقتی کارش تموم شد، سیگنال وقفه می‌فرسته.
- **گام ۳**: کنترل‌کننده وقفه سیگنال رو به CPU منتقل می‌کنه (از طریق پین).
- **گام ۴**: شماره وقفه به CPU می‌گه کدوم دستگاهه، و CPU کار لازم رو انجام می‌ده.
وقفه: یه تایمر می‌ذاری که وقتی آب جوشید بوق بزنه. تو این مدت می‌ری کار دیگه می‌کنی (مثل خرد کردن سبزی). وقتی تایمر بوق زد، برمی‌گردی سراغ قابلمه. وقفه تو کامپیوتر هم مثل همون تایمره که به CPU خبر می‌ده دستگاه آماده‌ست.

![](attachments/Pasted%20image%2020250614164818.png)
![](attachments/Pasted%20image%2020250614164841.png)
- واحد CPU به کنترل‌کننده DMA می‌گوید که داده را از دستگاه I/O (مثلاً دیسک) به حافظه منتقل کند.
	کنترل‌کننده DMA این کار را انجام می‌دهد و وقتی تمام شد، به CPU از طریق سیگنال وقفه (Interrupt) خبر می‌دهد.
	این فرآیند بدون نیاز به دخالت مداوم CPU انجام می‌شود.
- خود DMA یک سخت‌افزار است، اما به‌صورت یک واحد مستقل در CPU قرار ندارد. معمولاً به‌صورت یک کنترل‌کننده مجزا (DMA Controller) در مادربورد یا به‌عنوان بخشی از چیپ‌ست (Chipset) سیستم طراحی می‌شود.
- **Storage** :
![](attachments/Pasted%20image%2020250614170853.png)

## POSIX System Call

![](attachments/Pasted%20image%2020250614171715.png)

![](attachments/Pasted%20image%2020250614171720.png)



**گام ۱:** فراخوانی روال معمولی
برنامه کاربر تابع read را فراخوانی می‌کند که در واقع یک روال کتابخانه‌ای (مثلاً از کتابخانه استاندارد C) است. این روال ابتدا به‌عنوان یک تابع عادی اجرا می‌شود.
**گام ۲:** آماده‌سازی پارامترها
کامپایلرها (مثلاً C یا C++) پارامترهای فراخوانی (در اینجا fd, buffer, و nbytes) را به ترتیب معکوس روی پشته (Stack) قرار می‌دهند. این کار برای آماده‌سازی انتقال داده‌ها به روال بعدی است.
**گام ۳:** فراخوانی روال کتابخانه‌ای به زبان اسمبلی
روال کتابخانه‌ای read (که معمولاً به زبان اسمبلی نوشته شده) اجرا می‌شود. این روال یک فراخوانی سیستمی را آغاز می‌کند.
پارامترها از پشته به رجیسترهایی (مثل register) منتقل می‌شوند که سیستم‌عامل انتظار دریافت آن‌ها را دارد (مثلاً read با کد سیستمی خاص).
**گام ۴:** سوئیچ به مود هسته با دستور TRAP
روال کتابخانه‌ای از یک دستور خاص مثل TRAP یا INT (مثلاً int 0x80 در سیستم‌های قدیمی‌تر لینوکس) استفاده می‌کند. این دستور CPU را از مود کاربر (User Mode) به مود هسته (Kernel Mode) تغییر می‌دهد و اجرای سرویس موردنظر در سیستم‌عامل را آغاز می‌کند.
**گام ۵:** تنظیم جدول اشاره‌گرها
پس از سوئیچ، سیستم‌عامل از طریق یک جدول اشاره‌گرها (Interrupt Vector Table) که بر اساس شماره فراخوانی سیستمی (System Call Number) اندیس شده، به اداره‌کننده فراخوانی سیستمی (System Call Handler) مربوطه (مثلاً برای read) هدایت می‌شود.
**گام ۶:** اجرای اداره‌کننده
اداره‌کننده فراخوانی سیستمی در مود هسته اجرا می‌شود. این بخش کد سیستم‌عامل است که عملیات خواندن داده‌ها از دستگاه I/O (مثلاً دیسک یا فایل) را انجام می‌دهد.
**گام ۷:** پایان کار اداره‌کننده
وقتی اداره‌کننده کارش (مثلاً خواندن داده و ذخیره در بافر) تمام شد، کنترل به روال کتابخانه‌ای در فضای کاربر بازگردانده می‌شود. این بازگشت معمولاً پس از اجرای دستورالعمل بعد از TRAP انجام می‌شود.
**گام ۸:** بازگشت به برنامه کاربر
روال کتابخانه‌ای با استفاده از یک بازگشت معمولی (Return)، کنترل را به برنامه کاربر برمی‌گرداند و مقدار بازگشتی (مثلاً count) را به برنامه تحویل می‌دهد.
**گام ۹:** خالی کردن پشته
در پایان، برنامه کاربر باید پشته را خالی کند تا پارامترهای قبلی از آن حذف شوند و برای فراخوانی‌های بعدی آماده باشد.

![](attachments/Pasted%20image%2020250614172537.png)
![](attachments/Pasted%20image%2020250614172403.png)

![](attachments/Pasted%20image%2020250614172429.png)


![](attachments/Pasted%20image%2020250614172524.png)

![](attachments/Pasted%20image%2020250614174434.png)

![](attachments/Pasted%20image%2020250614174452.png)
![](attachments/Pasted%20image%2020250614174459.png)
![](attachments/Pasted%20image%2020250614174517.png)
![](attachments/Pasted%20image%2020250614174543.png)

![](attachments/Pasted%20image%2020250614174607.png)

![](attachments/Pasted%20image%2020250614174651.png)

![](attachments/Pasted%20image%2020250614174952.png)
